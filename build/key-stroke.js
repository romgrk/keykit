// Generated by CoffeeScript 1.8.0
(function() {
  var KeyStroke, kit, _;

  _ = require('underscore-plus');

  kit = require('./keykit');

  module.exports = KeyStroke = (function() {

    /*
    Section: key parsing
     */
    KeyStroke.parse = function(keysym) {
      kit = require('./keykit');
      if (keysym instanceof KeyStroke) {
        return keysym;
      }
      if (kit.isChar(keysym)) {
        return this.fromChar(keysym);
      }
      if (keysym.match(kit.normalKeyStrokeRegex)) {
        return this.fromKeyStroke(keysym);
      }
      if (kit.isVimEscaped(keysym)) {
        return this.fromVim(keysym);
      }
      return null;
    };

    KeyStroke.fromChar = function(c) {
      var char, code, identifier, name, shift;
      kit = require('./keykit');
      if (c == null) {
        throw new Error('No argument');
      }
      if (typeof c !== 'string') {
        throw new Error('argument is not a string: ' + typeof c);
      }
      if (c.length !== 1) {
        throw new Error('string exceeds 1 character');
      }
      char = c;
      shift = kit.isShifted(c);
      if (kit.isAlpha(c)) {
        name = kit.shift(c);
      } else if (kit.isVisible(c)) {
        name = kit.unshift(c);
      } else {
        name = (function() {
          switch (c) {
            case '\n':
              return 'enter';
            case '\t':
              return 'tab';
            case ' ':
              return 'space';
          }
        })();
      }
      code = kit.keycodeByName[name];
      identifier = kit.unicode(c);
      return new KeyStroke({
        shift: shift,
        name: name,
        code: code,
        identifier: identifier,
        char: char
      });
    };

    KeyStroke.fromVim = function(keysym) {
      var alt, char, code, ctrl, identifier, meta, mods, name, shift, vimkey, _ref;
      kit = require('./keykit');
      if (kit.isChar(keysym)) {
        return this.fromChar(keysym);
      }
      if (!kit.isVimEscaped(keysym)) {
        throw new Error("String doesn't represent a vim-notation. (" + keysym + ")");
      }
      _ref = keysym.match(kit.vimEscapedRegex).slice(2, 4), mods = _ref[0], vimkey = _ref[1];
      if (vimkey == null) {
        return null;
      }
      ctrl = /C-/i.test(mods);
      alt = /A-/i.test(mods);
      shift = /S-/i.test(mods);
      meta = /M-/i.test(mods);
      name = kit.keynameByVimCode[vimkey.toUpperCase()] || vimkey;
      if (kit.isShifted(name)) {
        name = kit.unshift(name);
        shift = true;
      }
      code = kit.keycodeByName[name];
      if (kit.isChar(name)) {
        identifier = kit.unicode(name);
      } else {
        identifier = name;
        char = (function() {
          switch (name) {
            case "enter":
              return "\n";
            case "space":
              return " ";
            case "tab":
              return "\t";
            default:
              return void 0;
          }
        })();
      }
      return new KeyStroke({
        ctrl: ctrl,
        alt: alt,
        shift: shift,
        meta: meta,
        name: name,
        code: code,
        identifier: identifier,
        char: char != null ? char : null
      });
    };

    KeyStroke.fromKeyStroke = function(keystroke) {
      var alt, code, ctrl, key, match, meta, mod, name, shift, _ref;
      kit = require('./keykit');
      if (keystroke.length === 1) {
        return this.fromChar(keystroke);
      }
      _ref = keystroke.match(kit.normalKeyStrokeRegex), match = _ref[0], key = _ref[1], mod = _ref[2];
      if (mod != null) {
        if (mod === 'cmd') {
          mod = 'meta';
        }
        if (mod === 'ctrl') {
          mod = 'control';
        }
        code = kit.key(mod).code;
        switch (mod) {
          case 'control':
            ctrl = true;
            break;
          case 'alt':
            alt = true;
            break;
          case 'shift':
            shift = true;
            break;
          case 'meta':
            meta = true;
        }
        return new KeyStroke({
          identifier: mod,
          name: mod,
          ctrl: ctrl != null ? ctrl : false,
          alt: alt != null ? alt : false,
          shift: shift != null ? shift : false,
          meta: meta != null ? meta : false,
          code: code
        });
      } else {
        ctrl = keystroke.match(/ctrl-/) != null;
        alt = keystroke.match(/alt-/) != null;
        shift = keystroke.match(/shift-/) != null;
        meta = (keystroke.match(/meta-/) != null) || (keystroke.match(/cmd-/) != null);
        if (key.length === 1) {
          name = kit.unshift(key);
        } else {
          name = key;
        }
        return new KeyStroke({
          ctrl: ctrl,
          alt: alt,
          shift: shift,
          meta: meta,
          name: name
        });
      }
    };

    KeyStroke.fromKBEvent = function(event) {
      var ks;
      kit = require('./keykit');
      if (event.type === 'keydown' || event.type === 'keyup') {
        return new KeyStroke({
          code: event.keyCode || event.which,
          ctrl: event.ctrlKey || false,
          alt: event.altKey || false,
          shift: event.shiftKey || false,
          meta: event.metaKey || false,
          name: kit.keynameByCode[event.keyCode || event.which],
          identifier: event.keyIdentifier || null
        });
      }
      if (event.type === 'keypress') {
        ks = this.fromChar(String.fromCharCode(event.charCode));
        ks.ctrl = event.ctrlKey;
        ks.alt = event.altKey;
        ks.meta = event.metaKey;
        return ks;
      }
      return null;
    };


    /*
    Section: instance
     */

    function KeyStroke(options) {
      var key, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
      if (options == null) {
        options = {};
      }
      if (kit == null) {
        kit = require('./keykit');
      }
      this.ctrl = (_ref = options.ctrl) != null ? _ref : false;
      this.alt = (_ref1 = options.alt) != null ? _ref1 : false;
      this.shift = (_ref2 = options.shift) != null ? _ref2 : false;
      this.meta = (_ref3 = options.meta) != null ? _ref3 : false;
      this.name = (_ref4 = options.name) != null ? _ref4 : null;
      this.char = (_ref5 = options.char) != null ? _ref5 : null;
      this.identifier = (_ref6 = options.identifier) != null ? _ref6 : null;
      this.code = (_ref7 = (_ref8 = (_ref9 = options.code) != null ? _ref9 : options.keyCode) != null ? _ref8 : options.keycode) != null ? _ref7 : null;
      if (this.code != null) {
        key = kit.findByCode(this.code);
        this.name = key.name;
      } else if (this.name != null) {
        key = kit.findByName(this.name);
        this.code = key.code;
      } else {
        throw new Error("Keycode or name needed");
      }
      if (this.char == null) {
        if (_.isArray(key.char)) {
          if (!this.shift) {
            this.char = key.char[0];
          }
          if (this.shift) {
            this.char = key.char[1];
          }
        } else {
          this.char = key.char;
        }
      }
    }

    KeyStroke.prototype.toString = function() {
      var s, visible;
      visible = kit.keysByCode[this.code].visible;
      if (kit.isModifier(this.code)) {
        return this.name;
      } else if (!(this.ctrl || this.alt) && visible) {
        return this.char;
      } else {
        s = "";
        s += (this.ctrl ? "ctrl-" : "");
        s += (this.alt ? "alt-" : "");
        s += (this.shift ? "shift-" : "");
        s += (this.meta ? "meta-" : "");
        s += this.name.toLowerCase();
        return s;
      }
    };

    KeyStroke.prototype.vimEscaped = function() {
      var kc, name, s, visible;
      kc = kit.keysByCode[this.code];
      visible = kc.visible;
      if (kit.isModifier(this.code)) {
        return '';
      }
      if (!(this.ctrl || this.alt) && visible) {
        if (typeof kc.char !== 'string') {
          if (this.char === '<') {
            return '<LT>';
          }
          if (!this.shift) {
            return kc.char[0];
          }
          if (this.shift) {
            return kc.char[1];
          }
        } else {
          return kc.char;
        }
      } else {
        s = "";
        s += (this.ctrl ? "C-" : "");
        s += (this.alt ? "A-" : "");
        s += (this.shift ? "S-" : "");
        s += (this.meta ? "M-" : "");
        name = kit.vimCodeByKeyname[this.name] || this.name.toLowerCase();
        if (name === 'LT') {
          name = '<LT>';
        }
        s += name;
        return "<" + s + ">";
      }
    };

    return KeyStroke;

  })();

}).call(this);
