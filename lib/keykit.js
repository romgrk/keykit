// Generated by CoffeeScript 1.8.0
(function() {
  var Key, KeyCode, KeyExecuter, KeyKit, KeyStroke, _, _ref,
    __slice = [].slice;

  console.debug = console.log;

  _ = require('underscore-plus');

  KeyStroke = require('./key-stroke');

  KeyExecuter = require('./key-executer');

  _ref = require('./key-code'), Key = _ref.Key, KeyCode = _ref.KeyCode;

  module.exports = KeyKit = {
    KeyKit: this,
    KeyExecuter: KeyExecuter,
    KeyStroke: KeyStroke,
    Key: Key,
    KeyCode: KeyCode,
    keynameByVimCode: {
      'BS': 'backspace',
      'TAB': 'tab',
      'CR': 'enter',
      'ESC': 'escape',
      'SPACE': 'space',
      'END': 'end',
      'HOME': 'home',
      'UP': 'up',
      'DOWN': 'down',
      'RIGHT': 'right',
      'LEFT': 'left',
      'DEL': 'delete',
      'BAR': '|',
      'LT': '<',
      '<LT>': '<',
      'F1': 'f1',
      'F2': 'f2',
      'F3': 'f3',
      'F4': 'f4',
      'F5': 'f5',
      'F6': 'f6',
      'F7': 'f7',
      'F8': 'f8',
      'F9': 'f9',
      'F10': 'f10',
      'F11': 'f11',
      'F12': 'f12',
      'F13': 'f13',
      'F14': 'f14',
      'F15': 'f15',
      'F16': 'f16',
      'F17': 'f17',
      'F18': 'f18',
      'F19': 'f19',
      'F20': 'f20',
      'F21': 'f21',
      'F22': 'f22',
      'F23': 'f23',
      'F24': 'f24',
      'CTRL': 'ctrl',
      'ALT': 'alt',
      'SHIFT': 'shift'
    },
    vimCodeByKeyname: {
      backspace: "BS",
      tab: "TAB",
      "return": "CR",
      enter: "CR",
      escape: "ESC",
      space: "SPACE",
      end: "END",
      home: "HOME",
      up: "UP",
      down: "DOWN",
      right: "RIGHT",
      left: "LEFT",
      "delete": "DEL",
      "|": "BAR",
      "<": "LT",
      f1: "F1",
      f2: "F2",
      f3: "F3",
      f4: "F4",
      f5: "F5",
      f6: "F6",
      f7: "F7",
      f8: "F8",
      f9: "F9",
      f10: "F10",
      f11: "F11",
      f12: "F12",
      f13: "F13",
      f14: "F14",
      f15: "F15",
      f16: "F16",
      f17: "F17",
      f18: "F18",
      f19: "F19",
      f20: "F20",
      f21: "F21",
      f22: "F22",
      f23: "F23",
      f24: "F24",
      ctrl: "CTRL",
      alt: "ALT",
      shift: "SHIFT",
      altgr: "ALTGR"
    },
    normalKeyStrokeRegex: /^(control|alt|shift)|(?:(ctrl-)?(alt-)?(shift-)?(.|enter|space|backspace|delete|tab|escape|pageup|pagedown|home|end|left|right|up|down|f\d{1,2}))$/,
    vimEscapedRegex: /<((?:((?:[CSAM]-)+)?(BS|TAB|CR|ESC|SPACE|PAGEUP|PAGEDOWN|END|HOME|LEFT|UP|RIGHT|DOWN|DEL|BAR|F\d{1,2}|<LT>|.))|LT)>/i,
    vimSequenceRegex: /([^<]|<((?:((?:[CSAM]-)+)?(BS|TAB|CR|ESC|SPACE|PAGEUP|PAGEDOWN|END|HOME|LEFT|UP|RIGHT|DOWN|DEL|BAR|F\d{1,2}|<LT>|.))|LT)>)/gi,

    /*
    Section: helpers
     */
    getChar: function(key) {
      var char;
      if (!this.isPrintable(key.code)) {
        return null;
      }
      char = this.keycharByCode[key.code];
      if (key.shift) {
        char = this.shift(char);
      }
      return char;
    },
    isAlpha: function(c) {
      return /a-zA-Z/.test(c);
    },
    unshift: function(c) {
      if (this.isUpperCase(c)) {
        return c.toLowerCase();
      }
      if (this.isShifted(c)) {
        return this.shiftedToUnshifted[c];
      }
      return c;
    },
    shift: function(c) {
      if (this.isLowerCase(c)) {
        return c.toUpperCase();
      }
      if (!this.isShifted(c)) {
        return this.unshiftedToShifted[c];
      }
      return c;
    },
    unicode: function(c) {
      var code;
      code = c.toLowerCase().charCodeAt(0).toString(16);
      switch (code.length) {
        case 1:
          return "U+000" + code;
        case 2:
          return "U+00" + code;
        case 3:
          return "U+0" + code;
        case 4:
          return "U+" + code;
        default:
          console.warn("Unicode: ", code);
          return "U+" + code;
      }
    },
    isShifted: function(c) {
      if (this.shiftedToUnshifted[c] != null) {
        return true;
      }
      if (this.isUpperCase(c)) {
        return true;
      }
      return false;
    },
    isLowerCase: function(c) {
      return !/[^a-z]/.test(c);
    },
    isUpperCase: function(c) {
      return !/[^A-Z]/.test(c);
    },
    isChar: function(c) {
      return c.length === 1;
    },
    isPrintable: function(arg) {
      if (typeof arg === "string") {
        return !_.contains(this.nonPrintableNames, arg);
      } else {
        return !_.contains(this.nonPrintableCodes, arg);
      }
    },
    isVisible: function(c) {
      if (c == null) {
        return false;
      }
      return /[^\s]/.test(c);
    },

    /*
    Section: key parsing
     */
    fromChar: function(c) {
      var char, code, identifier, name, shift;
      if (c == null) {
        console.error(new Error('no argument'));
      }
      if (typeof c !== 'string') {
        console.error(new Error('argument is not a string: ' + typeof c));
      }
      if (c.length !== 1) {
        return null;
      }
      char = c;
      shift = this.isShifted(c);
      if (this.isAlpha(c)) {
        name = this.shift(c);
      } else if (this.isVisible(c)) {
        name = this.unshift(c);
      } else {
        name = (function() {
          switch (c) {
            case '\n':
              return 'enter';
            case '\t':
              return 'tab';
            case ' ':
              return 'space';
          }
        })();
        if (name == null) {
          return null;
        }
        char = c;
      }
      code = this.keycodeByName[name];
      identifier = this.unicode(c);
      return new KeyStroke({
        shift: shift,
        name: name,
        code: code,
        identifier: identifier,
        char: char
      });
    },
    fromVim: function(keysym) {
      var alt, code, ctrl, identifier, meta, mods, name, shift, vimkey, _ref1;
      if (this.isChar(keysym)) {
        return this.fromChar(keysym);
      }
      if (!this.isVimEscaped(keysym)) {
        return null;
      }
      _ref1 = keysym.match(this.vimEscapedRegex).slice(2, 4), mods = _ref1[0], vimkey = _ref1[1];
      if (vimkey == null) {
        return null;
      }
      ctrl = /C-/i.test(mods);
      alt = /A-/i.test(mods);
      shift = /S-/i.test(mods);
      meta = /M-/i.test(mods);
      name = this.keynameByVimCode[vimkey.toUpperCase()] || vimkey;
      if (this.isShifted(name)) {
        name = this.unshift(name);
        shift = true;
      }
      code = this.keycodeByName[name];
      if (this.isChar(name)) {
        identifier = this.unicode(name);
      } else {
        identifier = name;
      }
      return new KeyStroke({
        ctrl: ctrl,
        alt: alt,
        shift: shift,
        meta: meta,
        name: name,
        code: code,
        identifier: identifier
      });
    },
    fromKeyStroke: function(keystroke) {
      var alt, ctrl, key, match, mod, name, shift, _ref1;
      console.debug(keystroke);
      console.debug(keystroke.match(this.normalKeyStrokeRegex));
      _ref1 = keystroke.match(this.normalKeyStrokeRegex), match = _ref1[0], mod = _ref1[1], ctrl = _ref1[2], alt = _ref1[3], shift = _ref1[4], key = _ref1[5];
      if (mod != null) {
        return console.debug(mod);
      } else {
        if (key.length === 1) {
          name = KeyKit.unshift(key);
        } else {
          name = key;
        }
        return console.debug(name);
      }
    },
    fromKBEvent: function(event) {
      return new KeyStroke({
        code: event.keyCode || event.which,
        ctrl: event.ctrlKey || false,
        alt: event.altKey || false,
        shift: event.shiftKey || false,
        name: this.keynameByCode[event.keyCode || event.which],
        identifier: event.keyIdentifier || null
      });
    },
    isVimEscaped: function(k) {
      return this.vimEscapedRegex.test(k);
    },
    getVisibleRepresentation: function(c) {
      switch (c) {
        case '\n':
          return '\\n';
        case ' ':
          return '\\s';
        case '\t':
          return '\\t';
        default:
          return c;
      }
    },
    getNormalizedKey: function(key) {
      var normalizedKey;
      if (!(key instanceof KeyStroke)) {
        key = this.resolveKey(key);
      }
      normalizedKey = "";
      if (key.ctrl) {
        normalizedKey += "ctrl-";
      }
      if (key.alt) {
        normalizedKey += "alt-";
      }
      if (this.isVisible(key.char)) {
        normalizedKey += key.char;
      } else {
        if (key.shift) {
          normalizedKey += "shift-";
        }
        normalizedKey += key.name;
      }
      return normalizedKey;
    },
    getNormalizedKeybinding: function(sequence) {
      var keys;
      keys = this.splitVimTokens(sequence);
      keys = _.map(keys, (function(_this) {
        return function(k) {
          return _this.getNormalizedKey(k);
        };
      })(this));
      return keys.join(" ");
    },
    splitVimTokens: function(sequence) {
      var matches;
      return matches = sequence.match(this.vimSequenceRegex);
    },
    resolveKey: function(keysym) {
      if (this.isChar(keysym)) {
        return this.fromChar(keysym);
      }
      if (this.isVimEscaped(keysym)) {
        return this.fromVim(keysym);
      }
      console.error("KeyKit: couldn't resolve key (" + keysym + ")");
      return null;
    },
    trigger: function(key) {
      var canceled, downEvent, _base;
      if (!(key instanceof KeyStroke)) {
        key = this.resolveKey(key);
      }
      if (key == null) {
        return;
      }
      downEvent = this.createKBEvent('keydown', key);
      canceled = !this.dispatch(downEvent);
      console.log('down: ', !canceled);
      console.log(downEvent);
      if (this.isPrintable(key.code)) {
        console.log('press: ', this.dispatch(this.createKBEvent('keypress', key)));
      }
      if (!canceled) {
        if (this.dispatch(this.createTextEvent(key))) {
          console.log("textInput: " + key.char);
          console.log(typeof (_base = document.activeElement).getModel === "function" ? _base.getModel().insertText(key.char) : void 0);
        }
      }
      return console.log('up: ', this.dispatch(this.createKBEvent('keyup', key)));
    },
    createKBEvent: function(type, key) {
      var args, e;
      e = document.createEvent('KeyboardEvent');
      args = [true, true, null, key.identifier, 0, key.ctrl, key.alt, key.shift, key.meta];
      e.initKeyboardEvent.apply(e, [type].concat(__slice.call(args)));
      Object.defineProperty(e, 'keykit', {
        get: function() {
          return true;
        }
      });
      if (type !== 'keypress') {
        Object.defineProperty(e, 'keyCode', {
          get: function() {
            return this._keyCode;
          }
        });
      } else {
        Object.defineProperty(e, 'keyCode', {
          get: function() {
            return this._keyChar.charCodeAt(0);
          }
        });
        Object.defineProperty(e, 'charCode', {
          get: function() {
            return this._keyChar.charCodeAt(0);
          }
        });
      }
      Object.defineProperty(e, 'which', {
        get: function() {
          return this._keyCode;
        }
      });
      Object.defineProperty(e, 'keyIdentifier', {
        get: function() {
          return this._keyIdentifier;
        }
      });
      e._keyIdentifier = key.identifier;
      e._keyCode = key.code;
      e._keyChar = key.char;
      e._name = key.name;
      e.target = document.activeElement;
      return e;
    },
    createTextEvent: function(key) {
      var e;
      e = document.createEvent('TextEvent');
      e.initTextEvent('textInput', true, true, document.activeElement, key.char);
      Object.defineProperty(e, 'keyCode', {
        get: function() {
          return this._keyCode;
        }
      });
      Object.defineProperty(e, 'which', {
        get: function() {
          return this._keyCode;
        }
      });
      e._keyCode = key.code;
      return e;
    },
    dispatch: function(event) {
      return document.activeElement.dispatchEvent(event);
    },
    executeSequence: function(sequence) {
      var k, _i, _len, _ref1, _results;
      _ref1 = this.splitVimTokens(sequence);
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        k = _ref1[_i];
        _results.push(this.trigger(k));
      }
      return _results;
    },
    executeKeys: function(keys) {
      var k, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = keys.length; _i < _len; _i++) {
        k = keys[_i];
        _results.push(this.trigger(k));
      }
      return _results;
    },
    getKeyExec: function(sequence) {
      var keyExecuter;
      keyExecuter = new KeyExecuter(sequence);
      return keyExecuter.handler;
    },
    getKeySequence: function(sequence) {
      var keys;
      keys = this.splitVimTokens(sequence);
      return _.map(keys, (function(_this) {
        return function(k) {
          return _this.resolveKey(k);
        };
      })(this));
    },
    createKeyExecuter: function(sequence) {
      var keyExecuter;
      keyExecuter = new KeyExecuter(sequence);
      return keyExecuter;
    }
  };

}).call(this);
